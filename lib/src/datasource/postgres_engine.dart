import 'package:postgres/postgres.dart';

import '../annotations/column.dart';
import '../migrations/schema.dart';
import 'engine_adapter.dart';

class PostgresEngine implements EngineAdapter {
  PostgresEngine._(this._open);

  final Future<Connection> Function() _open;
  Connection? _db;

  static PostgresEngine connect(
    Endpoint endpoint, {
    ConnectionSettings? settings,
  }) =>
      PostgresEngine._(() => Connection.open(endpoint, settings: settings));

  static PostgresEngine fromConnection(Connection connection) =>
      PostgresEngine._(() async => connection);

  @override
  Future<void> open() async {
    _db = await _open();
  }

  @override
  Future<void> close() async {
    final db = _db;
    if (db != null) {
      await db.close();
    }
    _db = null;
  }

  @override
  Future<void> executeBatch(List<String> statements) async {
    final db = _ensureDb();
    for (final s in statements) {
      final sql = _adaptSql(s);
      await db.execute(sql);
    }
  }

  @override
  Future<int> execute(String sql, [List<Object?> params = const []]) async {
    final db = _ensureDb();
    final adapted = _adaptSql(sql);
    final prepared = params.isEmpty ? adapted : _convertPlaceholders(adapted);
    final result = await db.execute(prepared, parameters: params);
    return result.affectedRows;
  }

  @override
  Future<List<Map<String, dynamic>>> query(String sql, [List<Object?> params = const []]) async {
    final db = _ensureDb();
    final prepared = params.isEmpty ? sql : _convertPlaceholders(sql);
    final result = await db.execute(prepared, parameters: params);
    return result
        .map((row) => row.toColumnMap().cast<String, dynamic>())
        .toList(growable: false);
  }

  @override
  Future<SchemaState> readSchema() async {
    final db = _ensureDb();
    final tables = <String, SchemaTable>{};

    final tableRows = await db.execute(
      "SELECT table_schema, table_name FROM information_schema.tables "
      "WHERE table_type = 'BASE TABLE' "
      "AND table_schema NOT IN ('pg_catalog', 'information_schema')",
    );

    for (final row in tableRows) {
      final rowMap = row.toColumnMap();
      final schema = rowMap['table_schema'] as String;
      final name = rowMap['table_name'] as String;

      final columns = <String, SchemaColumn>{};
      final columnRows = await db.execute(
        Sql.named(
          "SELECT column_name, is_nullable, data_type, udt_name "
          "FROM information_schema.columns "
          "WHERE table_schema = @schema AND table_name = @table "
          "ORDER BY ordinal_position",
        ),
        parameters: {
          'schema': schema,
          'table': name,
        },
      );

      final pkRows = await db.execute(
        Sql.named(
          "SELECT kcu.column_name "
          "FROM information_schema.table_constraints tc "
          "JOIN information_schema.key_column_usage kcu "
          "  ON tc.constraint_name = kcu.constraint_name "
          " AND tc.table_schema = kcu.table_schema "
          "WHERE tc.constraint_type = 'PRIMARY KEY' "
          "  AND tc.table_schema = @schema "
          "  AND tc.table_name = @table",
        ),
        parameters: {
          'schema': schema,
          'table': name,
        },
      );

      final pkColumns = pkRows.map((r) => r.toColumnMap()['column_name'] as String).toSet();

      for (final c in columnRows) {
        final cMap = c.toColumnMap();
        final cname = cMap['column_name'] as String;
        final nullable = (cMap['is_nullable'] as String?) == 'YES';
        final dataType = cMap['data_type'] as String?;
        final udtName = cMap['udt_name'] as String?;
        columns[cname] = SchemaColumn(
          name: cname,
          type: _mapType(dataType, udtName),
          nullable: nullable,
          isPrimaryKey: pkColumns.contains(cname),
        );
      }

      tables[name] = SchemaTable(name: name, columns: columns);
    }

    return SchemaState(tables: tables);
  }

  String _adaptSql(String sql) {
    var adapted = sql;
    adapted = adapted.replaceAll(
      RegExp(r'PRIMARY\\s+KEY\\s+AUTOINCREMENT', caseSensitive: false),
      'GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY',
    );
    adapted = adapted.replaceAll(
      RegExp(r'\\bAUTOINCREMENT\\b', caseSensitive: false),
      'GENERATED BY DEFAULT AS IDENTITY',
    );
    adapted = adapted.replaceAll(
      RegExp(r'\\bBLOB\\b', caseSensitive: false),
      'BYTEA',
    );
    adapted = adapted.replaceAll(
      RegExp(r'\\bDOUBLE\\b', caseSensitive: false),
      'DOUBLE PRECISION',
    );
    return adapted;
  }

  String _convertPlaceholders(String sql) {
    var index = 0;
    var inSingle = false;
    var inDouble = false;
    final out = StringBuffer();
    for (var i = 0; i < sql.length; i++) {
      final ch = sql[i];
      if (ch == "'" && !inDouble) {
        if (inSingle && i + 1 < sql.length && sql[i + 1] == "'") {
          out.write("''");
          i++;
          continue;
        }
        inSingle = !inSingle;
        out.write(ch);
        continue;
      }
      if (ch == '"' && !inSingle) {
        if (inDouble && i + 1 < sql.length && sql[i + 1] == '"') {
          out.write('""');
          i++;
          continue;
        }
        inDouble = !inDouble;
        out.write(ch);
        continue;
      }
      if (ch == '?' && !inSingle && !inDouble) {
        index += 1;
        out.write('\$${index}');
        continue;
      }
      out.write(ch);
    }
    return out.toString();
  }

  ColumnType _mapType(String? dataType, String? udtName) {
    final type = (dataType ?? '').toUpperCase();
    final udt = (udtName ?? '').toUpperCase();
    if (type.contains('INT') || udt.contains('INT')) return ColumnType.integer;
    if (type.contains('CHAR') || type.contains('TEXT') || udt.contains('CHAR')) return ColumnType.text;
    if (type.contains('BOOL')) return ColumnType.boolean;
    if (type.contains('DOUBLE') || type.contains('REAL') || type.contains('NUMERIC')) {
      return ColumnType.doublePrecision;
    }
    if (type.contains('TIMESTAMP') || type.contains('DATE') || type.contains('TIME')) {
      return ColumnType.dateTime;
    }
    if (type.contains('JSON')) return ColumnType.json;
    if (type.contains('BYTEA')) return ColumnType.binary;
    return ColumnType.text;
  }

  Connection _ensureDb() {
    final db = _db;
    if (db == null) {
      throw StateError('PostgresEngine is not open');
    }
    return db;
  }
}
